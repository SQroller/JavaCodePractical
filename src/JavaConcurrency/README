1. Практическая задача - Concurrency - блокирующая очередь

Предположим, у вас есть пул потоков, и вы хотите реализовать блокирующую очередь для передачи задач между потоками. Создайте класс BlockingQueue, 
который будет обеспечивать безопасное добавление и извлечение элементов между производителями и потребителями в контексте пула потоков.
Класс BlockingQueue должен содержать методы enqueue() для добавления элемента в очередь и dequeue() для извлечения элемента. Если очередь пуста, 
dequeue() должен блокировать вызывающий поток до появления нового элемента.
очередь должна иметь фиксированный размер.
Используйте механизмы wait() и notify() для координации между производителями и потребителями. Реализуйте метод size(), который возвращает текущий размер очереди.

Решение в классах: BlockingQueue

2. Практическая задача - Concurrency - многопоточный банковский счет

В виртуальном банке "ConcurrentBank" решено внедрить многопоточность для обработки операций по счетам клиентов. 
Система должна поддерживать возможность одновременного пополнения (deposit), снятия (withdraw), а также переводов (transfer) между счетами. Каждый счет имеет свой уникальный номер.
Реализуйте класс BankAccount с методами deposit, withdraw и getBalance, поддерживающими многопоточное взаимодействие.
Реализуйте класс ConcurrentBank для управления счетами и выполнения переводов между ними. 
Класс должен предоставлять методы createAccount для создания нового счета и transfer для выполнения переводов между счетами.
Переводы между счетами должны быть атомарными, чтобы избежать ситуаций, когда одна часть транзакции выполняется успешно, а другая нет.
Реализуйте метод getTotalBalance, который возвращает общий баланс всех счетов в банк.

Решение в классах: ConcurrentBankExample - класс из услвоия, ConcurrentBank, BankAccount.

3. Практическое задание - Concurrency - синхронизаторы

Синхронизация потоков с использованием CyclicBarrier и ExecutorService
В этой задаче мы будем использовать CyclicBarrier и ExecutorService для синхронизации нескольких потоков, выполняющих сложную задачу, и затем ожидающих, пока все потоки завершат выполнение, 
чтобы объединить результаты.
Создайте класс ComplexTask, представляющий сложную задачу, которую несколько потоков будут выполнять. В каждой задаче реализуйте метод execute(), который выполняет часть сложной задачи.
Создайте класс ComplexTaskExecutor, в котором будет использоваться CyclicBarrier и ExecutorService для синхронизации выполнения задач. Реализуйте метод executeTasks(int numberOfTasks), 
который создает пул потоков и назначает каждому потоку экземпляр сложной задачи для выполнения. Затем используйте CyclicBarrier для ожидания завершения всех потоков и объединения результатов их работы. 
В методе main создайте экземпляр ComplexTaskExecutor и вызовите метод executeTasks с несколькими задачами для выполнения.

Решение в классах: TestComplexTaskExecutor - класс для тестирования, ComplexTask, ComplexTaskExecutor.
